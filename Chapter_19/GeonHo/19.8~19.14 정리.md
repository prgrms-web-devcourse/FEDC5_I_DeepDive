## 19.8 오버라이딩과 프로퍼티 섀도잉

`오버라이딩`이란? <br>

- 상위 클래스의 메서드를 하위 클래스에서 재정의하는 것을 말한다.

`프로퍼티 섀도잉`이란? <br>

- 프로토타입 프로퍼티와 같은 이름의 프로퍼티를 인스턴스에 추가하면, 프로토타입 프로퍼티를 덮어쓰는 것이 아닌 인스턴스 프로퍼티로 추가된다.
- 이렇게 프로퍼티를 오버라이딩하여 상속 관계에 의한 프로퍼티가 가려지는 현상이 프로퍼티 섀도잉이다.

<br>

**인스턴스 등의 하위 객체를 통해 상위 프로토타입의 프로퍼티를 변경 또는 삭제하는 것은 불가능하다.** <br>
다시 말해, get은 허용되나 set은 허용되지 않는다

<br>

## 19.9 프로토타입의 교체

프로토타입은 임의의 다른 객체로 변경할 수 있다. <br>
생성자 함수의 prototype 또는 인스턴스의 **proto** 접근자 프로퍼티를 통해 프로토타입을 교체할 수 있다.

```js
const Person = (function () {
  function Person(name) {
    this.name = name;
  }

  // Person 생성자 함수의 프로토타입을 아래 객체로 교체하였다.
  Person.prototype = {
    sayHello() {
      console.log(`Hi! My name is ${this.name}`);
    },
  };

  return Person;
})();

const me = new Person("Lee");
```

위 코드에서 Person 생성자 함수의 프로토타입을 새로운 객체로 교체했다. <br>
다만, 위 프로토타입 객체는 constructor 프로퍼티가 없다. <br>
때문에 인스턴스 me는 생성자 함수가 Person이 아닌 Object다.

```js
console.log(me.constructor === Person); // false
console.log(me.constructor === Object); // true
```

<br>

생성자 함수가 Person을 가르키게하려면 아래와 같이 객체를 수정하면 된다.

```js
Person.prototype = {
  constructor: Person,
  sayHello() {
    console.log(`Hi! My name is ${this.name}`);
  },
};
```

위와 같이 생성자 함수를 활용한 프로토타입 교체 방식과 인스턴스의 **proto** 접근자 프로퍼티를 활용한 프로토타입 교체 방식은 조금 다르다. <br>
생성자 함수의 경우, 생성자함수는 생성자 함수.prototype을 가르키지만 인스턴스의 **proto** 접근자 프로퍼티를 사용한 방식은 그렇지 않다. <br>

<br>

## 19.10 instanceof 연산자

```js
객체 instanceof 생성자 함수
```

instanceof 연산자는 생성자 함수의 prototype에 바인딩된 객체가 객체의 프로토타입 체인 상에 존재하면 true를 반환한다. <br>

<br>

## 19.11 직접 상속

## 19.12 정적 프로퍼티/메서드

어떤 생성자 함수 객체가 소유한 프로퍼티/메서드를 뜻한다.

정적 프로퍼티/메서드는 new로 생성된 인스턴스도 참조할 수 없다. <br>
왜냐하면 인스턴스로 참조할 수 있는 프로퍼티/메서드는 프로토타입 체인 상에 존재해야하기 때문인데, <br>
정적 프로퍼티/메서드는 생성자 함수 객체에 바인딩되어 있기 때문이다.

정적 프로퍼티/메서드와 프로토타입 프로퍼티/메서드의 차이점은 <br>
`생성자함수.fn()` 인지 `생성자함수.prototype.fn()` 로 구분할 수 있다.

<br>

## 19.13 프로퍼티 존재 확인

### in

in 연산자는 확인 대상 객체 뿐 아니라, 상속받은 모든 프로토타입 프로퍼티를 확인한다.

```js
const person = {
  name: "Lee",
  address: "Seoul",
};

console.log("name" in person); // true
console.log("address" in person); // true
console.log("age" in person); // false
console.log("toString" in person); // true
// toString은 Object.prototype의 메서드이다.
// person 객체가 Object.prototype을 상속받았으므로 true를 리턴한다.
```

### hasOwnProperty

상속받은 프로퍼티의 경우 false를 리턴, 고유 프로퍼티의 key인 경우에만 true를 리턴한다.

<br>

## 19.14 프로퍼티 열거

### for...in

for...in 문은 객체의 프로퍼티를 열거할 때 사용한다. <br>
in 연산자와 마찬가지로 상속받은 프로토타입의 프로퍼티까지 열거한다.

해서 vsc의 for...in 문의 snippet을 보면 다음과 같이 hasOwnProperty 메서드가 포함되어 있다.

```js
for (const key in object) {
    if (Object.hasOwnProperty.call(object, key)) {
        const element = object[key];
        ...
    }
}
```

다만, Object.prototype의 toString 같은 프로퍼티는 열거하지 않는다. <br>

왜일까? <br>
이는 프로퍼티의 열거 가능 여부를 판별하는 `내부 슬롯 [[Enumerable]]`이 false이기 때문이다.

또한, for...in은 열거시 순서를 보장하지 않는다. <br>
다만, 대부분의 브라우저에서는 순서를 보장하고, *숫자인 프로퍼티 키에 대해서는 정렬*을 한다.

<br>

객체 자신의 고유 프로퍼티만 열거하기 위해서는 for...in 문 보다는 Object.keys / values / entries 메서드를 사용하는 것이 좋다.

### Object.keys

```js
const person = {
  name: "Lee",
  address: "Seoul",
  __proto__: { age: 20 },
};

console.log(Object.keys(person)); // ['name', 'address']
```

객체 자신의 열거 가능한 프로퍼티 키를 **배열**로 반환한다.

<br>

### Object.values

```js
console.log(Object.values(person)); // ['Lee', 'Seoul']
```

'' value를 배열로 반환한다.

<br>

### Object.entries

```js
console.log(Object.entries(person)); // [['name', 'Lee'], ['address', 'Seoul']]
```

'' key, value를 배열로 반환한다.
